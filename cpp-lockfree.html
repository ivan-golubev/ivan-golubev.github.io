<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Ivan Golubev" />
  <meta name="keywords" content="C++" />
  <title>cpp-lockfree</title>
  <style>
    html {
      font-family: Verdana, sans-serif;
      font-size: 22px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 48em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        background-color: #232629;
        color: #7a7c7d;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #7a7c7d;  padding-left: 4px; }
    div.sourceCode
      { color: #cfcfc2; background-color: #232629; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #cfcfc2; } /* Normal */
    code span.al { color: #95da4c; background-color: #4d1f24; font-weight: bold; } /* Alert */
    code span.an { color: #3f8058; } /* Annotation */
    code span.at { color: #2980b9; } /* Attribute */
    code span.bn { color: #f67400; } /* BaseN */
    code span.bu { color: #7f8c8d; } /* BuiltIn */
    code span.cf { color: #fdbc4b; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #3daee9; } /* Char */
    code span.cn { color: #27aeae; font-weight: bold; } /* Constant */
    code span.co { color: #7a7c7d; } /* Comment */
    code span.cv { color: #7f8c8d; } /* CommentVar */
    code span.do { color: #a43340; } /* Documentation */
    code span.dt { color: #2980b9; } /* DataType */
    code span.dv { color: #f67400; } /* DecVal */
    code span.er { color: #da4453; text-decoration: underline; } /* Error */
    code span.ex { color: #0099ff; font-weight: bold; } /* Extension */
    code span.fl { color: #f67400; } /* Float */
    code span.fu { color: #8e44ad; } /* Function */
    code span.im { color: #27ae60; } /* Import */
    code span.in { color: #c45b00; } /* Information */
    code span.kw { color: #cfcfc2; font-weight: bold; } /* Keyword */
    code span.op { color: #cfcfc2; } /* Operator */
    code span.ot { color: #27ae60; } /* Other */
    code span.pp { color: #27ae60; } /* Preprocessor */
    code span.re { color: #2980b9; background-color: #153042; } /* RegionMarker */
    code span.sc { color: #3daee9; } /* SpecialChar */
    code span.ss { color: #da4453; } /* SpecialString */
    code span.st { color: #f44f4f; } /* String */
    code span.va { color: #27aeae; } /* Variable */
    code span.vs { color: #da4453; } /* VerbatimString */
    code span.wa { color: #da4453; } /* Warning */
  </style>
  <link rel='icon' type='image/png' href='/img/favicon.png'>
  <script src="/scripts/theme_switch.js"></script>
  <link rel="stylesheet" href="/themes/fonts_colors.css">
  <!-- Use Ubuntu fonts for text from https://fonts.google.com/selection/embed -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">

  <!-- google analytics -->
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-JQY9PQZ2MZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-JQY9PQZ2MZ');
  </script>
</head>
<body>
<h1>
<a href="/index.html">Welcome to Ivan Golubev's tech blog !</a>
</h1>
<h1 id="using-atomics-for-lock-free-programming-in-c">Using atomics for
lock free programming in C++</h1>
<p>A simple way to avoid <strong>race conditions</strong> and
<strong>Undefined Behavior (UB)</strong> when accessing shared memory
for read-writes from multiple threads is to use mutexes.</p>
<p>However this is not the only way. An alternative is to use the
properties of atomic instructions provided by your computer
architecture.</p>
<p>In this post I will cover the important aspects of lock-free
programming.<br />
A very good source I have used to summarize the theory on this topic is
<strong>C++ Concurrency in Action</strong> <a href="#1">[1]</a>.</p>
<p>All data in a C++ program is made up of objects - a region of
storage, which could hold scalar values such as chars, ints or composite
structures such as <code>mystruct*</code>.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> scalar<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> mystruct <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y<span class="op">:</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> z<span class="op">:</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Usually each object will occupy at least one memory location.
Variables of fundamental types such as <code>int</code> and
<code>char</code> occupy exactly one memory location. In this example
variables <code>y</code> and <code>z</code> are adjacent bitfields and
will share the same <code>integer</code> location and the total size of
the struct will be 64 bytes.</p>
<p>This part is crucial for multithreaded apps in C++: everything hinges
on those memory locations. There cannot be race conditions when two
threads access separate memory locations.<br />
Moreover, even if the same memory location is accessed read-only from
multiple threads - no synchronization or protection is needed.</p>
<p>When at least one of the threads is modifying the data - there is a
potential for a race condition.<br />
To avoid this - an enforced ordering between accesses in the two threads
is needed.</p>
<p>One way to enforce ordering is to use mutexes. Another - atomic
operations either on the same or other memory locations.<br />
Every object in a C++ program has a modification order composed of all
the writes to that object from all threads, starting with the object’s
initialization.</p>
<p>For non-atomic types a programmer is responsible for making certain
that there’s sufficient synchronization to ensure threads agree on the
modification order of each variable.<br />
If different threads see distinct sequences of values for a single
variable, you have a <strong>data race</strong> and
<strong>UB</strong>.</p>
<p><code>std::atomic&lt;&gt;</code> class template defines atomic types
for scalar types on the current platform. On most popular platforms it’s
expected that the atomic variants of all the built-in types are
lock-free, but it isn’t guaranteed.<br />
Use <code>std::atomic&lt;T&gt;::is_always_lock_free</code> to check if
the current platform provides the necessary instructions.</p>
<p>The operations on the atomic types are <code>load()</code>,
<code>store()</code>, <code>compare_exchange_strong()</code>,
<code>compare_exchange_weak()</code>.<br />
Each of this operations has an optional memory-ordering argument.</p>
<p>For store operations: <code>memory_order_relaxed</code>,
<code>memory_order_release</code>,
<code>memory_order_seq_cst</code>.</p>
<p>For load operations: <code>memory_order_seq_cst</code>,
<code>memory_order_acquire</code>,
<code>memory_order_seq_cst</code>.</p>
<p>For read-modify-write operations: <code>memory_order_relaxed</code>,
<code>memory_order_acquire</code>, <code>memory_order_release</code>,
<code>memory_order_acq_rel</code>,
<code>memory_order_seq_cst</code>.</p>
<p>Compare-exchange operation is the cornerstone of programming with
atomic types. The are two flavours:
<code>std::atomic&lt;T&gt;::compare_exchange_strong</code> and
<code>std::atomic&lt;T&gt;::compare_exchange_weak</code>.<br />
It compares the value of an atomic variable with a supplied expected
value and stores the supplied desired value if they are equal <a
href="#2">[2]</a>.<br />
If the values aren’t equal, the expected value is updated with the value
of the atomic variable.<br />
When store was performed the compare_exchange function returns
<code>true</code>.</p>
<p>The <code>weak</code> version might not succeed even if the expected
value was seen. This spurios failure can happen on machines lacking a
single compare-and-exchange instruction.<br />
The compare-exchange functions can take two memory ordering parameters:
success - the memory synchronization ordering for the read-modify-write
operation if the comparison succeeds; failure - the memory sync ordering
for the load operation if the comparison fails.</p>
<p>Suppose you have two threads, one of which is populating a data
structure to be read by the second.<br />
To avoid race conditions an atomic flag is used. For this to work there
must be an enforced ordering.<br />
It comes from the operations on <code>std::atomic&lt;bool&gt;</code> -
they provide the necessary ordering via the memory model relations:
<code>happens-before</code> and <code>synchronizes-with</code>.</p>
<p>When you have an enforced ordering the write of the data
<code>happens-before</code> the read of the data.<br />
The main idea is this: a suitably tagged atomic write operation on a
variable <code>x</code>, <code>synchronizes-with</code> a suitably
tagged atomic read operation on <code>x</code>.<br />
As for this tagging - there are three models:<br />
1. sequentially consistent<br />
2. acquire-release ordering<br />
3. relaxed ordering</p>
<p>Sequential consistency is the most straightforward and intuitive
ordering, but also the most expensive because it requires global
synchronization between all threads.<br />
On a multiprocessor system this may require extensive and time consuming
communication between processors.</p>
<p>To avoid this cost you have to use non-sequentially consistent memory
orderings where there is no longer a single global order of
events.<br />
It is not just that the compiler can reoder the instructions. Even if
the threads are running the same bit of code, they can disagree on the
order of events, because the different CPU caches and internal buffers
can hold different values for the same memory.</p>
<p>The opposite of the sequentially consistent model is the relaxed
ordering where no synchronization is happening. Relaxed atomic
operations must be used in combination with atomic operations that
feature stronger ordering semantics in order to be useful for
inter-thread synchronization.</p>
<p>One way to achieve additional synchronization without the overhead of
full-blown sequential consistency is to use <code>acquire-release</code>
ordering.</p>
<p>Under this ordering model, atomic loads are <code>acquire</code>
operations, atomic store are <code>release</code> operations, and atomic
read-modify-write operations are either <code>acquire</code>,
<code>release</code> or both (<code>memory_order_acq_rel</code>). When
this model is used, a <code>release</code> operation
<code>synchronizes-with</code> an <code>acquire</code> operation that
reads the value written.</p>
<p>As an example, let us implement a Stack datastructure, which is
thread-safe, but does not rely on a mutex (i.e. is lock-free) and does
not use the sequential memory ordering when.</p>
<p>We will have a <code>Node</code> struct, which will be used to chain
nodes.<br />
The top of the stack is an atomic variable.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">*</span> next<span class="op">{</span><span class="kw">nullptr</span><span class="op">};</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Stack <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>atomic<span class="op">&lt;</span>Node<span class="op">*&gt;</span> top<span class="op">{</span><span class="kw">nullptr</span><span class="op">};</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> empty<span class="op">();</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> push<span class="op">(</span><span class="dt">int</span> value<span class="op">);</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> pop<span class="op">();</span>  </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Let’s implement the methods of the stack.<br />
First we check if it is empty.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> Stack<span class="op">::</span>empty<span class="op">()</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">*</span> node <span class="op">=</span> top<span class="op">.</span>load<span class="op">(</span><span class="bu">std::</span>memory_order::acquire<span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> node <span class="op">==</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Then to add new values into the stack - we create a new Node and try
to atomically swap it with the current top of the stack.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Stack<span class="op">::</span>push<span class="op">(</span><span class="dt">int</span> value<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">*</span> node <span class="op">=</span> <span class="kw">new</span> Node<span class="op">{</span> value <span class="op">};</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    node<span class="op">-&gt;</span>next <span class="op">=</span> top<span class="op">.</span>load<span class="op">(</span><span class="bu">std::</span>memory_order::relaxed<span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>top<span class="op">.</span>compare_exchange_weak<span class="op">(</span>node<span class="op">-&gt;</span>next<span class="op">,</span> node<span class="op">,</span> <span class="bu">std::</span>memory_order::release<span class="op">,</span> <span class="bu">std::</span>memory_order::relaxed<span class="op">))</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This has to happen in a loop because the swap will not succeed when
the expected value (the first argument) of the top is not the same as
what we have assigned to the new Node-&gt;next variable. When this fails
- the instruction overwrites the node-&gt;next variable and tries
again.</p>
<p>Finally the method returns when the top of the stack is correctly
updated. Note that the <code>memory_order_release</code> is used to make
this operation visible to other threads.
<code>std::memory_order::release</code> is enough because we only need
to publish a new <code>top</code> node to other threads.</p>
<p>Now to the <code>pop</code> operation. Here we have to get the
current top of the stack and set the top of the stack to the next
node.<br />
This can be done in a thread-safe way using
<code>compare_exchange_weak</code> on the atomic <code>top</code>
variable with the help of the
<code>std::memory_order::acq_rel</code>.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Stack<span class="op">::</span>pop<span class="op">()</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">*</span> node <span class="op">=</span> top<span class="op">.</span>load<span class="op">(</span><span class="bu">std::</span>memory_order::acquire<span class="op">);</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>top<span class="op">.</span>compare_exchange_weak<span class="op">(</span>node<span class="op">,</span> node<span class="op">-&gt;</span>next<span class="op">,</span> <span class="bu">std::</span>memory_order::acq_rel<span class="op">,</span> <span class="bu">std::</span>memory_order::relaxed<span class="op">))</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data <span class="op">=</span> node<span class="op">-&gt;</span>data<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> node<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We use <code>acq_rel</code> because <code>acquire</code> is needed to
safely read <code>node-&gt;next</code> and <code>release</code> to
ensure the <code>top</code> update is visible to other threads.</p>
<p>Please note that calling <code>pop()</code> on an empty stack is
<strong>UB</strong> just as in the stack data structure in STL: you have
to check the precondition with <code>Stack::empty()</code> method.</p>
<p>Let’s add a couple of functions to push and pop values into/from this
stack.<br />
The first function will periodically (every 100 milliseconds) push
values into the stack until a stop is requested.<br />
The second function will periodically pop values from the stack and when
a stop is requested - it will pop all remaining values from the
stack.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> push_values<span class="op">(</span>Stack<span class="op">&amp;</span> stack<span class="op">,</span> <span class="bu">std::</span>stop_source<span class="op">&amp;</span> stop_src<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stop_token stop_tkn <span class="op">=</span> stop_src<span class="op">.</span>get_token<span class="op">();</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>stop_tkn<span class="op">.</span>stop_requested<span class="op">())</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        stack<span class="op">.</span>push<span class="op">(++</span>value<span class="op">);</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>osyncstream<span class="op">(</span><span class="bu">std::</span>cout<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">&quot;&lt;- pushed </span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>this_thread::sleep_for<span class="op">(</span><span class="dv">100</span><span class="bu">ms</span><span class="op">);</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> pop_values<span class="op">(</span>Stack<span class="op">&amp;</span> stack<span class="op">,</span> <span class="bu">std::</span>stop_source<span class="op">&amp;</span> stop_src<span class="op">)</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stop_token stop_tkn <span class="op">=</span> stop_src<span class="op">.</span>get_token<span class="op">();</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// if stop is requested - keep popping until the stack is empty</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>stop_tkn<span class="op">.</span>stop_requested<span class="op">()</span> <span class="op">||</span> stop_tkn<span class="op">.</span>stop_requested<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>stack<span class="op">.</span>empty<span class="op">())</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>stack<span class="op">.</span>empty<span class="op">())</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>osyncstream<span class="op">(</span><span class="bu">std::</span>cout<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">&quot;  -&gt; popped </span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> stack<span class="op">.</span>pop<span class="op">());</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>this_thread::sleep_for<span class="op">(</span><span class="dv">100</span><span class="bu">ms</span><span class="op">);</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Let us start two threads that will push new values and one thread to
pop values from the stack.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    Stack stack<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stop_source stop_src<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>jthread t1<span class="op">(</span>push_values<span class="op">,</span> <span class="bu">std::</span>ref<span class="op">(</span>stack<span class="op">),</span> <span class="bu">std::</span>ref<span class="op">(</span>stop_src<span class="op">));</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>jthread t2<span class="op">(</span>push_values<span class="op">,</span> <span class="bu">std::</span>ref<span class="op">(</span>stack<span class="op">),</span> <span class="bu">std::</span>ref<span class="op">(</span>stop_src<span class="op">));</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>jthread t3<span class="op">(</span>pop_values<span class="op">,</span> <span class="bu">std::</span>ref<span class="op">(</span>stack<span class="op">),</span> <span class="bu">std::</span>ref<span class="op">(</span>stop_src<span class="op">));</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>this_thread::sleep_for<span class="op">(</span><span class="dv">1</span><span class="bu">s</span><span class="op">);</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        stop_src<span class="op">.</span>request_stop<span class="op">();</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>stack<span class="op">.</span>empty<span class="op">());</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>After one second we request a stop. The expected behavior - threads
<code>t1</code> and <code>t2</code> will stop adding new values.<br />
Then thread <code>t3</code> will keep popping the values until the stack
is empty.</p>
<p>Let’s run the code and see the console output:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 1</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 1</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 2</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 2</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 2</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 3</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 3</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 3</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 4</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 4</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 4</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 5</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 5</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 5</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 6</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 6</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 6</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 7</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 7</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 7</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 8</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 8</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 8</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 9</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 9</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 9</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 10</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>- <span class="ex">pushed</span> 10</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 10</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 10</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 9</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 8</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 7</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 6</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 5</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 4</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 3</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 2</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 1</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-</span><span class="op">&gt;</span> popped 1</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a><span class="ex">lockfree.exe</span> <span class="er">(</span><span class="ex">process</span> 27392<span class="kw">)</span> <span class="ex">exited</span> with code 0 <span class="er">(</span><span class="ex">0x0</span><span class="kw">)</span><span class="bu">.</span></span></code></pre></div>
<p>The main thread joins on all worker threads upon exit from the scope
where <code>std::jthreads</code> are created.<br />
Once all worker threads exit - we can assert that the stack is
empty.</p>
<p>However one has to be careful with such asserts - here we add values
at double the rate (threads <code>t1</code> and <code>t2</code>) at
which we remove them (thread <code>t3</code>).</p>
<p>If there were only one thread to push values and different sleep
timings were used we could get a situation when the thread running the
<code>pop_values()</code> function was the first to receive the stop
request and the stack was empty at that point. As a result this thread
exits.<br />
At the same time the thread running the <code>push_values()</code>
function was in the body of the while loop pushing a new value. It will
only check the stop signal at the next iteration.<br />
As a result - the last value will not be popped and the assert will
trigger in the main thread.</p>
<p>As we can see in this example - we created a thread-safe stack
without relying on mutexes (i.e. it is lock free) and sequentially
consistent memory order.</p>
<p>All code for this topic is available on <a
href="https://github.com/ivan-golubev/cpp-lock-free-stack">Github</a>.</p>
<p><a name="1">[1] <a
href="https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition">C++
Concurrency in Action, Second Edition. Anthony Williams.
2019</a></a></p>
<p><a name="2">[2] <a
href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange">cppreference
- Compare Exchange</a></a></p>
<p>
If you noticed an error or just want to drop me a message - reach me via <a href="https://www.linkedin.com/in/igolubev">LinkedIn</a> or <a href="mailto:&#105;&#118;&#097;&#110;&#064;&#100;&#097;&#114;&#107;&#109;&#097;&#103;&#105;&#099;&#046;&#100;&#101;&#118;">email</a>.
</p>

<a href="/" class="hide-on-index-page">Home</a>
<script src="/scripts/main.js"></script>
<div id="bottom-marker" style="height: 1px;"></div>
</body>
</html>
