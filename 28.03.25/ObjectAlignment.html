<!DOCTYPE html>
<html>

<head>
    <title>Object alignment in C++</title>
	<link href="themes/styles.css" rel="stylesheet"/>
	<link href="themes/prism.css" rel="stylesheet"/>
</head>

<body>
	<h1>Object alignment in C++</h1>
	<script src="scripts/prism.js"></script>
<p>
When you think about how an object in C++ is represented in memory you have to be aware of alignment <a href="#footnote1">[1]</a>.<br/>
Structs and struct fields are aligned on memory word boundaries to make sure the memory access is efficient.<br/>
For example reading a primitive data type like int64_t on a x86-64 architecture results in a single memory word access
when this object is aligned at 8 byte boundary.
</p>

<p>
If the object is not aligned properly - accessing such an object could result in unnecessary reading of multiple memory words.<br/>
To make matters worse, when the second part of the object is in a separate page within a virtual memory system - a TLB miss or a page fault
may occur <a href="#footnote2">[2]</a>. <br/>
This would hurt the performance even more.
</p>

<p>
The alignment of a struct is the strictest (largest) alignment of any of its members
and compiler may add padding between members to ensure proper alignment.
</p>

<p>
Let us see how structs are represented in memory in C++ and their size and alignment using this helper function:
</p>
<pre><code class="language-cpp">
template&lt;typename T&gt;
void printTypeSizeAlign(const T&amp; value)
{
	std::cout &lt;&lt; std::format("sizeof({}): {} bytes, align: {} bytes\n", typeid(value).name(), sizeof(value), alignof(T));
}
</code></pre>

<p>
In a simple scenario we have the expected each field take 4 bytes and this is the alignment of the struct.
</p>
<pre><code class="language-cpp">
struct TwoInts
{
	int first{};
	int second{};
};
TwoInts x;
printTypeSizeAlign(x);	
// sizeof(struct TwoInts): 8 bytes, align: 4 bytes
</code></pre>

<p>
An empty struct takes the minimum addressable size in computer memory - a single byte.
The size is also non zero because distinct instances of an empty struct should have distinct addresses <a href="#footnote3">[3]</a>.
</p>
<pre><code class="language-cpp">
struct Empty {};
Empty x;
printTypeSizeAlign(x);
//sizeof(struct Empty): 1 bytes, align: 1 bytes
</code></pre>

<p>
A struct inheriting from an empty base <a href="#footnote3">[3]</a> have the empty base optimized away from the object layout in memory,
which results in expected 4 byte size/ alignment.
</p>
<pre><code class="language-cpp">
struct ChildOfEmpty : public Empty
{
	int first{};
};
ChildOfEmpty x;
printTypeSizeAlign(x);
// sizeof(struct ChildOfEmpty): 4 bytes, align: 4 bytes
</code></pre>

<p>
To make sure that the larger field (int second) is aligned on a 4 byte boundary a compiler
has to insert a 2 byte padding. This results in a larger size of the object than the sum of its members (6 bytes).
</p>
<pre><code class="language-cpp">
struct ShortAndInt
{
	short first{};
	int second{};
};
ShortAndInt x;
printTypeSizeAlign(x);
// sizeof(struct ShortAndInt): 8 bytes, align: 4 bytes
</code></pre>

<p>
This highlights the importance of order of the members and generally it is preferable to declare larger fields before
smaller fields to avoid wasting space on padding.
</p>
<pre><code class="language-cpp">
struct IntAndTwoShorts
{
	int first{};
	short second{};
	short third{};
};
IntAndTwoShorts x;
printTypeSizeAlign(x);
// sizeof(struct IntAndTwoShorts): 8 bytes, align: 4 bytes
</code></pre>

<p>
A stricter alignment (with larger alignment requirement) can be requested using alignas <a href="#footnote4">[4]</a>.
Note that it still has to be a power of two and cannot be smaller than the sum of the size of the elements.
</p>
<pre><code class="language-cpp">
struct alignas(alignof(double)) StricterAlignmentStruct
{
	int first;
};
StricterAlignmentStruct x;
printTypeSizeAlign(x);
// sizeof(struct StricterAlignmentStruct): 8 bytes, align: 8 bytes
</code></pre>

<p>
Let us also see the effect on the size and alignment when bit fields are used.
</p>
<pre><code class="language-cpp">
struct TwoChars
{
	char first;
	char second;
};

struct BitFieldStruct
{
	char first : 4;
	char second : 4;
};
TwoChars x1;
printTypeSizeAlign(x1);
BitFieldStruct x2;
printTypeSizeAlign(x2);
// sizeof(struct TwoChars): 2 bytes, align: 1 bytes
// sizeof(struct BitFieldStruct): 1 bytes, align: 1 bytes
</code></pre>

<p>
To finish this topic - to see what is the largest alignment for all scalar types on the current platform:
</p>
<pre><code class="language-cpp">
std::cout &lt;&lt; "Max scalar type alignment on this platform: " &lt;&lt; alignof(std::max_align_t);
// Max scalar type alignment on this platform: 8
</code></pre>

<p>
All code for this topic is available on <a href="https://github.com/ivan-golubev/structsinmemory">Github</a>.
</p>

<p id="footnote1">[1] <a href="https://en.cppreference.com/w/cpp/language/object#Alignment">Cppreference - Alignment</a></p>
<p id="footnote2">[2] <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data structure alignment Wiki</a></p>
<p id="footnote3">[3] <a href="https://en.cppreference.com/w/cpp/language/ebo">Cppreference - Empty base optimization</a></p>
<p id="footnote4">[4] <a href="https://en.cppreference.com/w/cpp/language/alignas">Cppreference - align as specifier</a></p>

<p>
If you noticed an error or just want to drop me a message - reach me via <a href="https://www.linkedin.com/in/igolubev">LinkedIn</a> or email at <a href="mailto:ivan@darkmagic.dev?subject=hello">ivan@darkmagic.dev</a>.
</p>

<script src="https://utteranc.es/client.js"
        repo="ivan-golubev/structsinmemory"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</body>

</html>